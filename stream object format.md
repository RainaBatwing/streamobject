## Draft Stream Object format

**This spec is *very experimental* and should not be used for anything ever**
at least not yet!

Stream Objects are containers designed to securely store several files, and
can be safely replicated to friends computers for distributed storage.
Encryption allows your intended audience to discover decryption keys and
access the content. This specification is inspired by
[miniLock](https://minilock.io/) but not compatible with it. Here are some
features:

  * Decryption speed stays fast even with a large number of audience members.
  * Encryption is relatively fast, if you cache curve25519 shared keys.
  * Tens of thousands of files can be attached. Files can be hundreds of
    gigabytes in size.
  * Individual files can be randomly accessed streamed out in 1MiB chunks.
  * Everything is hashed and signed with author's public key to verify
    authenticity and integrity. Author's identity is not concealed.

Stream Objects were designed with the goal of storing social media posts like
blog entries, for replication via distributed networks.

Objects contain the following parts concatenated:

1. "StreamOb" as ASCII/UTF8
2. length of part 3 - uint32 network byte order
3. Message Pack header object, described below
4. Encrypted Body
5. Last 64 bytes: ed25519 signature of blake2s hash of parts 1â€“4

### Header Object

```coffeescript
header = {
  id: Buffer(32 random uuid bytes)
  version: 1 # only A exists so far
  author: # author's public keys
    ed25519: Buffer(ed25519 public key)
    curve25519: Buffer(ed25519 public key)
  # used to determine caching duration, trumping, and quota  
  kind: "post", "profile", or "private" # kind of content
  timestamp: 1415238668655 # milliseconds since unix epoch
  # decryption keys for each audience member
  audience: {
    digestLength: 2 # digest length in bytes

    # one permit for each audience member. Permit's are indexed by a 8 byte
    # blake2s hash of the salt + the shared key generated by curve25519
    # between this audience member's public key and our private key
    "hex encoding of Digest Index (explained below)": [
      # usually one CipherPermit would exist in this array
      Buffer(CipherPermit)
      # but sometimes more may exist, if there is a hashIndex collision
      Buffer(another CipherPermit)
    ]
  }
  private: buffer containing secretbox encrypted msgpack encoded object {
    files:[
      # example first file's plaintext is 251 bytes long
      ["post.html", "text/html", 251],
      # second file 1521 bytes long
      ["catface.jpg", "image/jpeg", 1521]
    ]
  }
}
```

`private` is encoded with messagepack, encrypted with the secretbox nacl
function and stored as a buffer. The secretbox nonce is calculated as if it were
an attached file with index -1, as a single chunk with chunk index 0.

```
CipherPermit is a 24 byte nonce concatenated with the output of
nacl.box(CipherPermitPlaintext, nonce). CipherPermitPlaintext contains:
  nonce18 (18 bytes random nonce)
  secret (32 bytes nacl.secretbox key)
these details can be used to decrypt "private" section of header
and attached files.
CipherPermit's nonce must not be reused
CipherPermitPlaintext is identical for every recipient.
```

Digest Index is calculated in this way:

```coffeescript
# compute shared curve25519 key
sharedKey = nacl.box.before(header.author.curve25519, local curve25519 secret key)
# digest it concatenated together with unique nonce (the document uuid)
digest = blake2s(header.id + sharedKey, header.audience.digestLength)
# convert to hex encoding
index = digest.toString('hex')
```

Digest Length should be chosen to keep the number of CipherPermits in each
hashtable index to be a low number - ideally one or two. For most uses a
digestLength of `2` is plenty.

### Appended file data

Files listed in the `header.private.files` section are encrypted and appended
in the order specified in the header using tweetnacl's secretbox function. For
files larger than 1MiB, the file is split in to chunks of exactly 1MiB, with
the final chunk shorter as necessary.

Each chunk is encrypted with the secret key from CipherPermit, as well as a
unique nonce:

```coffeescript
# psuedocode: bytes concatenated
chunk_nonce = nonce18 + signed_int16(file_index) + unsigned_int32(chunk_index)
# resulting chunk_nonce is 24 bytes long.
```

### Speedy unlocking

CipherPermits are stored in a hash table indexed by a salted hash of the
curve25519 shared key between the document author and recipient. This should
leak at a maximum `header.audience.digestLength * 8` bits of the shared key,
if blake2s were compromised.

My initial benchmarking of the tweetnacl.js library indicated attempting decrypt
of 1000 CipherPermits on a moderately powerful laptop takes about 300 to 500
milliseconds. This is prohibitively slow as my main use case would includes
hundreds if not thousands of permits, and needs to run on devices slower than
my laptop.

I'm by no means a security expert. This is experimental and nobody has audited
it or even agreed that the design is good. I highly recommend checking out
@kaepora's miniLock if you don't need accelerated unlocking or random access
multiple file storage.

 ~~<3 Raina
