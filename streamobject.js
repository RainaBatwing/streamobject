// Generated by CoffeeScript 1.8.0
(function() {
  var BLAKE2s, BufferReadStream, BufferWriteStream, ChunkCipher, ChunkDecipher, ChunkSize, EphemeralNonceLength, FileID, FileStart, GenericChunkCipher, HashIndexBytes, NonceFor, StreamDigester, StreamObjectReader, StreamObjectWriter, bs58, fs, nacl, stream,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  nacl = require('tweetnacl/nacl-fast');

  BLAKE2s = require('blake2s-js');

  stream = require('stream');

  fs = require('fs');

  bs58 = require('bs58');

  FileStart = "StreamOb";

  ChunkSize = 1024 * 1024;

  HashIndexBytes = 2;

  NonceFor = function(ephemeralNonce, file_idx, chunk_idx) {
    var dataview, nonce;
    if (ephemeralNonce.length !== EphemeralNonceLength) {
      throw new "nonce length incorrect";
    }
    nonce = new Uint8Array(nacl.secretbox.nonceLength);
    nonce.set(ephemeralNonce);
    dataview = new DataView(nonce.buffer, EphemeralNonceLength);
    dataview.setInt16(0, file_idx);
    dataview.setUint32(2, chunk_idx);
    return nonce;
  };

  EphemeralNonceLength = 18;

  FileID = {
    PrivateSection: -1
  };

  StreamObjectReader = (function() {
    function StreamObjectReader(options) {
      var callback, data;
      if (options == null) {
        options = {};
      }
      data = options.data;
      callback = options.callback;
      if (!data) {
        throw "data must be provided to constructor";
      }
      if (typeof data === 'string') {
        fs.open(data, 'r', null, (function(_this) {
          return function(err, fd) {
            if (err) {
              return callback(err);
            }
            options.data = fd;
            return _this.constructor(options);
          };
        })(this));
        return;
      }
      if (typeof data === 'number') {
        this._data = data;
        this._readData = this._readDataFromFilesystem;
      } else {
        this._data = new Buffer(data);
        this._readData = this._readDataFromBuffer;
      }
      this._readData(0, FileStart.length + 4, (function(_this) {
        return function(err, start) {
          var headerLength;
          if (err) {
            return callback(err);
          }
          if (start.slice(0, FileStart.length).toString() !== FileStart) {
            return callback("Provided data is not a StreamObject");
          }
          headerLength = start.readUInt32BE(FileStart.length);
          return _this._readData(start.length, headerLength, function(err, rawHeader) {
            var key, value, _ref;
            if (err) {
              return callback(err);
            }
            if (rawHeader.length < headerLength) {
              return callback("File truncated inside header");
            }
            _this.header = JSON.parse(rawHeader);
            _ref = _this.header.author;
            for (key in _ref) {
              value = _ref[key];
              _this.header.author[key] = new Uint8Array(bs58.decode(value));
            }
            _this._headerEnd = start.length + rawHeader.length;
            return callback(err);
          });
        };
      })(this));
    }

    StreamObjectReader.prototype.unlock = function(recipientSecretKeys) {
      var audienceSalt, cipherPermit, cipherPermitBase58, digest, hashIndex, permit, permitBox, permitNonce, privateBox, privateNonce, privatePlain, secretKey, sharedKey, sharedKeys, _i, _j, _len, _len1, _ref;
      if (this.permit) {
        return true;
      }
      if (recipientSecretKeys == null) {
        throw new Error("first argument required");
      }
      if (recipientSecretKeys.map == null) {
        recipientSecretKeys = [recipientSecretKeys];
      }
      audienceSalt = bs58.decode(this.header.audience.salt);
      sharedKeys = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = recipientSecretKeys.length; _i < _len; _i++) {
          secretKey = recipientSecretKeys[_i];
          if (typeof secretKey === 'string') {
            secretKey = bs58.decode(secretKey);
          }
          _results.push(nacl.box.before(this.header.author.curve25519, secretKey));
        }
        return _results;
      }).call(this);
      for (_i = 0, _len = sharedKeys.length; _i < _len; _i++) {
        sharedKey = sharedKeys[_i];
        digest = new BLAKE2s(HashIndexBytes);
        digest.update(audienceSalt);
        digest.update(sharedKey);
        hashIndex = bs58.encode(digest.digest());
        _ref = this.header.audience[hashIndex] || [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          cipherPermitBase58 = _ref[_j];
          cipherPermit = new Uint8Array(bs58.decode(cipherPermitBase58));
          permitNonce = cipherPermit.subarray(0, nacl.box.nonceLength);
          permitBox = cipherPermit.subarray(nacl.box.nonceLength);
          permit = nacl.box.open.after(permitBox, permitNonce, sharedKey);
          if (!permit) {
            continue;
          }
          permit.nonce = permit.subarray(0, EphemeralNonceLength);
          permit.secret = permit.subarray(EphemeralNonceLength);
          privateBox = nacl.util.decodeBase64(this.header["private"]);
          privateNonce = NonceFor(permit.nonce, -1, 0);
          privatePlain = nacl.secretbox.open(privateBox, privateNonce, permit.secret);
          if (!privatePlain) {
            continue;
          }
          this.permit = permit;
          this.header["private"] = JSON.parse(nacl.util.encodeUTF8(privatePlain));
          return this;
        }
      }
      return false;
    };

    StreamObjectReader.prototype.list = function() {
      var index, name, size, sourceOffset, type, _i, _len, _ref, _ref1;
      if (!this.permit) {
        throw new Error("Cannot read files from locked StreamObject");
      }
      if (this._list) {
        return this._list;
      }
      sourceOffset = this._headerEnd;
      this._list = {};
      _ref = this.header["private"].files;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        _ref1 = _ref[index], name = _ref1[0], type = _ref1[1], size = _ref1[2];
        this._list[name] = new StreamObjectReader.FileInfo(name, type, size, index);
      }
      return this._list;
    };

    StreamObjectReader.prototype.read = function(filename) {
      var decipher, file, fileEnd, fileList, fileSequence, fileStart, iFile, overhead, topUpDecipher, _i, _len, _ref;
      if (!this.permit) {
        throw new Error("Cannot read files from locked StreamObject");
      }
      fileList = this.list();
      fileSequence = [];
      for (iFile in fileList) {
        fileSequence[iFile.index] = iFile;
      }
      file = fileList[filename];
      if (!file) {
        return null;
      }
      decipher = new ChunkDecipher({
        chunkSize: ChunkSize,
        crypto: this.permit,
        fileInfo: file
      });
      fileStart = this._headerEnd;
      _ref = fileSequence.slice(0, file.index);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        iFile = _ref[_i];
        overhead = Math.ceil(iFile.size / ChunkSize) * nacl.secretbox.overheadLength;
        fileStart += iFile.size + overhead;
      }
      overhead = Math.ceil(file.size / ChunkSize) * nacl.secretbox.overheadLength;
      fileEnd = fileStart + file.size + overhead;
      topUpDecipher = (function(_this) {
        return function() {
          if (fileStart < fileEnd) {
            return _this._readData(fileStart, Math.min(fileEnd - fileStart, 1024 * 128), function(err, data) {
              var morePlz;
              if (err) {
                return decipher.emit("error", err);
              }
              morePlz = decipher.write(data);
              fileStart += data.length;
              if (morePlz) {
                return topUpDecipher();
              } else {
                return decipher.once("drain", topUpDecipher);
              }
            });
          } else {
            return decipher.end();
          }
        };
      })(this);
      topUpDecipher();
      return decipher;
    };

    StreamObjectReader.prototype._readData = function(start, length, callback) {
      return setImmediate(callback, "constructor didn't override _readData correctly");
    };

    StreamObjectReader.prototype._readDataFromFilesystem = function(start, length, callback) {
      var buffer;
      buffer = new Buffer(length);
      return fs.read(this._data, buffer, 0, length, start, function(err, bytesRead) {
        if (err) {
          return callback(err);
        }
        return callback(null, buffer.slice(0, bytesRead));
      });
    };

    StreamObjectReader.prototype._readDataFromBuffer = function(start, length, callback) {
      return setImmediate(callback, null, this._data.slice(start, start + length));
    };

    return StreamObjectReader;

  })();

  StreamObjectReader.FileInfo = (function() {
    function FileInfo(name, type, size, index) {
      this.name = name;
      this.type = type;
      this.size = size;
      this.index = index;
    }

    FileInfo.prototype.toString = function() {
      return this.name;
    };

    return FileInfo;

  })();

  StreamObjectWriter = (function() {
    function StreamObjectWriter(options) {
      var ephemeralNonce, ephemeralSecret;
      if (options == null) {
        options = {};
      }
      this.author = options.author || {
        curve25519: nacl.box.keyPair(),
        ed25519: nacl.sign.keyPair()
      };
      this.header = {
        id: options.id || bs58.encode(nacl.randomBytes(16)),
        author: {
          ed25519: bs58.encode(this.author.ed25519.publicKey),
          curve25519: bs58.encode(this.author.curve25519.publicKey)
        },
        version: 'A',
        timestamp: Date.now(),
        "private": {
          kind: options.kind || 'post',
          files: []
        }
      };
      this._audienceSalt = nacl.randomBytes(8);
      this.header.audience = {
        salt: bs58.encode(this._audienceSalt)
      };
      ephemeralNonce = nacl.randomBytes(EphemeralNonceLength);
      ephemeralSecret = nacl.randomBytes(nacl.secretbox.keyLength);
      this.permit = new Uint8Array(ephemeralNonce.length + ephemeralSecret.length);
      this.permit.nonce = this.permit.subarray(0, ephemeralNonce.length);
      this.permit.secret = this.permit.subarray(ephemeralNonce.length);
      this.permit.nonce.set(ephemeralNonce);
      this.permit.secret.set(ephemeralSecret);
      this.addRecipient(this.author.curve25519.publicKey);
      this.hash = new BLAKE2s(32);
      this.files = [];
    }

    StreamObjectWriter.prototype.addRecipient = function(publicKey) {
      var blake, cipherPermit, hashIndex, permitBox, permitNonce, sharedKey, _base;
      if (publicKey instanceof String) {
        publicKey = bs58.decode(publicKey);
      }
      sharedKey = nacl.box.before(publicKey, this.author.curve25519.secretKey);
      blake = new BLAKE2s(HashIndexBytes);
      blake.update(this._audienceSalt);
      blake.update(sharedKey);
      hashIndex = bs58.encode(blake.digest());
      cipherPermit = new Uint8Array(nacl.box.nonceLength + this.permit.length + nacl.box.overheadLength);
      permitNonce = nacl.randomBytes(nacl.box.nonceLength);
      permitBox = nacl.box.after(this.permit, permitNonce, sharedKey);
      cipherPermit.set(permitNonce, 0);
      cipherPermit.set(permitBox, permitNonce.length);
      (_base = this.header.audience)[hashIndex] || (_base[hashIndex] = []);
      return this.header.audience[hashIndex].push(bs58.encode(cipherPermit));
    };

    StreamObjectWriter.prototype.addFileData = function(name, data, type) {
      var fileInfo;
      if (type == null) {
        type = "text/plain";
      }
      if (data.constructor !== Buffer) {
        data = new Buffer(data);
      }
      fileInfo = {
        name: name,
        source: new BufferReadStream(data),
        size: data.length,
        type: type
      };
      this.files.push(fileInfo);
      return this.header["private"].files.push([fileInfo.name, fileInfo.type, fileInfo.size]);
    };

    StreamObjectWriter.prototype.addFile = function(name, path, type) {
      var fileInfo;
      if (type == null) {
        type = "";
      }
      fileInfo = {
        name: name,
        source: fs.createReadStream(path),
        size: fs.statSync(path).size,
        type: type
      };
      this.files.push(fileInfo);
      return this.header["private"].files.push([fileInfo.name, fileInfo.type, fileInfo.size]);
    };

    StreamObjectWriter.prototype.write = function(raw_stream, callback) {
      var file, fileIndex, jsonHeader, jsonHeaderLength, _i, _len, _ref;
      if (this.written && callback) {
        return setImmediate(callback, 'Already written');
      }
      this.written = true;
      if (raw_stream instanceof String) {
        raw_stream = fs.createWriteStream(raw_stream);
      }
      stream = new StreamDigester();
      stream.pipe(raw_stream);
      stream.on("error", callback);
      this.header["private"] = nacl.util.encodeBase64(nacl.secretbox(nacl.util.decodeUTF8(JSON.stringify(this.header["private"])), NonceFor(this.permit.nonce, FileID.PrivateSection, 0), this.permit.secret));
      stream.write(FileStart);
      jsonHeader = JSON.stringify(this.header);
      jsonHeaderLength = new Buffer(4);
      jsonHeaderLength.writeUInt32BE(Buffer.byteLength(jsonHeader), 0);
      stream.write(jsonHeaderLength);
      stream.write(jsonHeader);
      _ref = this.files;
      for (fileIndex = _i = 0, _len = _ref.length; _i < _len; fileIndex = ++_i) {
        file = _ref[fileIndex];
        file.index = fileIndex;
      }
      return this._writeNextFile(stream, this.files, (function(_this) {
        return function(err) {
          if (err) {
            return callback(err);
          } else {
            stream.unpipe();
            stream.on("finish", function() {
              var digest, signature_blob;
              digest = stream.digest();
              signature_blob = nacl.sign.detached(digest, _this.author.ed25519.secretKey);
              raw_stream.on("finish", callback);
              return raw_stream.end(new Buffer(signature_blob));
            });
            return stream.end();
          }
        };
      })(this));
    };

    StreamObjectWriter.prototype._writeNextFile = function(output, files, callback) {
      var cipher, thisFile;
      if (!files[0]) {
        return callback();
      }
      thisFile = files[0];
      cipher = new ChunkCipher({
        fileInfo: thisFile,
        crypto: this.permit
      });
      thisFile.source.pipe(cipher);
      cipher.on('readable', (function(_this) {
        return function() {
          return output.write(cipher.read());
        };
      })(this));
      cipher.on('finish', (function(_this) {
        return function() {
          return _this._writeNextFile(output, files.slice(1), callback);
        };
      })(this));
      return cipher.on('error', (function(_this) {
        return function(err) {
          return callback(err);
        };
      })(this));
    };

    return StreamObjectWriter;

  })();

  GenericChunkCipher = (function(_super) {
    __extends(GenericChunkCipher, _super);

    GenericChunkCipher.prototype._inputOverhead = 0;

    function GenericChunkCipher(options) {
      if (options == null) {
        options = {};
      }
      this.chunkSize = (options.chunkSize || ChunkSize) + this._inputOverhead;
      if (options.fileInfo == null) {
        throw new Error("fileInfo argument is not optional");
      }
      this.fileInfo = options.fileInfo;
      this._chunkIndex = 0;
      this.crypto = options.crypto;
      this._buffer = new Buffer(0);
      options.highWaterMark = this.chunk_size;
      GenericChunkCipher.__super__.constructor.call(this, options);
    }

    GenericChunkCipher.prototype._transform = function(appendbuf, encoding, done) {
      var err;
      this._buffer = Buffer.concat([this._buffer, appendbuf]);
      while (this._buffer.length >= this.chunkSize && !err) {
        err = this._chunkOut();
      }
      return done(err);
    };

    GenericChunkCipher.prototype._flush = function(done) {
      var err;
      while (this._buffer.length > 0 && !err) {
        err = this._chunkOut();
      }
      return done(err);
    };

    GenericChunkCipher.prototype._chunkOut = function() {
      var input, output;
      input = this._buffer.slice(0, this.chunkSize);
      this._buffer = this._buffer.slice(this.chunkSize);
      output = this._process(new Uint8Array(input));
      if (!output) {
        return "Crypto Failure";
      }
      this._chunkIndex += 1;
      this.push(new Buffer(output));
      return null;
    };

    return GenericChunkCipher;

  })(stream.Transform);

  ChunkDecipher = (function(_super) {
    __extends(ChunkDecipher, _super);

    function ChunkDecipher() {
      return ChunkDecipher.__super__.constructor.apply(this, arguments);
    }

    ChunkDecipher.prototype._inputOverhead = nacl.secretbox.overheadLength;

    ChunkDecipher.prototype._process = function(ciphertext) {
      var plaintext;
      return plaintext = nacl.secretbox.open(ciphertext, NonceFor(this.crypto.nonce, this.fileInfo.index, this._chunkIndex), this.crypto.secret);
    };

    return ChunkDecipher;

  })(GenericChunkCipher);

  ChunkCipher = (function(_super) {
    __extends(ChunkCipher, _super);

    function ChunkCipher() {
      return ChunkCipher.__super__.constructor.apply(this, arguments);
    }

    ChunkCipher.prototype._inputOverhead = 0;

    ChunkCipher.prototype._process = function(plaintext) {
      var ciphertext;
      return ciphertext = nacl.secretbox(plaintext, NonceFor(this.crypto.nonce, this.fileInfo.index, this._chunkIndex), this.crypto.secret);
    };

    return ChunkCipher;

  })(GenericChunkCipher);

  StreamDigester = (function(_super) {
    __extends(StreamDigester, _super);

    function StreamDigester(options) {
      if (options == null) {
        options = {};
      }
      this.hash = new BLAKE2s(options.digestLength || 32);
      StreamDigester.__super__.constructor.call(this, options);
    }

    StreamDigester.prototype._transform = function(buffer, encoding, done) {
      this.hash.update(new Uint8Array(buffer));
      return done(null, buffer);
    };

    StreamDigester.prototype.digest = function() {
      return this.hash.digest();
    };

    StreamDigester.prototype.hexDigest = function() {
      return this.hash.hexDigest();
    };

    return StreamDigester;

  })(stream.Transform);

  BufferReadStream = (function(_super) {
    __extends(BufferReadStream, _super);

    function BufferReadStream(buffer, options) {
      if (options == null) {
        options = {};
      }
      this.buffer = buffer;
      if (!(this.buffer instanceof Buffer)) {
        this.buffer = new Buffer(this.buffer);
      }
      this.index = 0;
      BufferReadStream.__super__.constructor.call(this, options);
    }

    BufferReadStream.prototype._read = function(size) {
      var slice;
      if (this.index + size > this.buffer.length) {
        size = this.buffer.length - this.index;
      }
      slice = this.buffer.slice(this.index, this.index + size);
      this.push(slice);
      this.index += size;
      if (this.index >= this.buffer.length) {
        return this.push(null);
      }
    };

    return BufferReadStream;

  })(stream.Readable);

  BufferWriteStream = (function(_super) {
    __extends(BufferWriteStream, _super);

    function BufferWriteStream(options) {
      if (options == null) {
        options = {};
      }
      this.buffers = [new Buffer(0)];
      this.length = 0;
      BufferWriteStream.__super__.constructor.call(this, options);
    }

    BufferWriteStream.prototype._write = function(chunk, encoding, done) {
      this.buffers.push(chunk);
      this.length += chunk.length;
      return done();
    };

    BufferWriteStream.prototype.getBuffer = function() {
      if (!(this.buffers.length <= 1)) {
        this.buffers = [Buffer.concat(this.buffers, this.length)];
      }
      return this.buffers[0];
    };

    return BufferWriteStream;

  })(stream.Writable);

  module.exports = {
    ChunkCipher: ChunkCipher,
    ChunkDecipher: ChunkDecipher,
    StreamDigester: StreamDigester,
    BufferReadStream: BufferReadStream,
    BufferWriteStream: BufferWriteStream,
    Reader: StreamObjectReader,
    Writer: StreamObjectWriter
  };

}).call(this);
