## Draft Stream Object format

**This spec is *very experimental* and should not be used for anything ever**
at least not yet!

Stream Objects are containers designed to securely store several files, and
can be safely replicated to friends computers for distributed storage.
Encryption allows your intended audience to discover decryption keys and
access the content. This specification is inspired by
[miniLock](https://minilock.io/) but not compatible with it. Here are some
features:

  * Decryption speed stays fast even with a large number of audience members.
  * Encryption is relatively fast, if you cache curve25519 shared keys.
  * Tens of thousands of files can be attached. Files can be hundreds of
    gigabytes in size.
  * Individual files can be decrypted randomly as needed and streamed out in
    1MiB chunks.
  * Everything is hashed and signed with author's public key to verify
    authenticity and integrity.

Stream Objects were designed with the goal of storing social media posts,
like blog entries, for replication via distributed networks.

Objects contain the following parts concatenated:

1. "StreamOb" as ASCII/UTF8
2. length of part 3 - uint32 network byte order
3. JSON header object in plaintext, described below
4. Encrypted Body
5. Last 64 bytes: ed25519 signature of blake2s hash of parts 1â€“4

### Header JSON Object

```coffeescript
header = {
  id: "b58string of 128 random bytes"
  version: "A" # only A exists so far
  keys: # author's public keys
    ed25519: "b58string"
    curve25519: "b58string"
  # decryption keys for each audience member
  audience:
    salt: "b58string 64bits of entropy"
    # one permit for each audience member. Permit's are indexed by a 8 byte
    # blake2s hash of the salt + the shared key generated by curve25519
    # between this audience member's public key and our private key
    "b58string of blake2s index hash (4 byte digest length)": [
      # usually one CipherPermit would exist in this array
      "b58string of CipherPermit"
      # but sometimes more may exist, if there is a hash collision during write
      "b58string of another CipherPermit"
    ]
    # CipherPermit is a 24 byte nonce concatenated with the output of
    # nacl.box(CipherPermitPlaintext, nonce). CipherPermitPlaintext contains:
    #   nonce18 (18 bytes random nonce)
    #   secret (32 bytes nacl.secretbox key)
    # these details can be used to decrypt "private" and attached files
    # CipherPermit's nonce must be totally random, and is never reused
    # CipherPermitPlaintext is identical for every recipient.
  private: secretbox encrypted(
    "kind": "post", "profile", or "private" # kind of content
    "timestamp": 1415238668655 # milliseconds since unix epoch
    "files":[
      # example first file's plaintext is 251 bytes long
      ["post.html", "text/html", 251],
      # second file 1521 bytes long
      ["catface.jpg", "image/jpeg", 1521]
    ]
  )
}
```

b58string = base58, encoded using bitcoin alphabet, like bs58 npm module.

`private` is converted to a JSON string, encrypted with the secretbox tweetnacl
function and base64 encoded. The secretbox nonce is calculated as if it were
an attached file with index -1, as a single chunk with chunk index 0

### Appended file data

Files listed in the `header.private.files` section are encrypted and appended
in the order specified in the header using tweetnacl's secretbox function. For
files larger than 1MiB, the file is split in to chunks of exactly 1MiB, with
the final chunk shorter as necessary.

Each chunk is encrypted with the secret key from CipherPermit, as well as a
unique nonce:

```coffeescript
# psuedocode: bytes concatenated
chunk_nonce = nonce18 + signed_int16(file_index) + unsigned_int32(chunk_index)
# resulting chunk_nonce is 24 bytes long.
```


### Speedy unlocking

CipherPermits are stored in a hash table, keyed by a short 4 byte hash of
the CipherPermit's shared key. This shared key is only known by the recipient
and the author, as it is derived from their curve25519 keys. This surely
weakens security at least somewhat, as some information is known about the
shared key in plaintext. The author (Raina) does not know if this is a terrible
idea. Benchmarking with the tweetnacl.js library indicated attempting decrypt
of 1000 CipherPermits on a moderately powerful laptop takes about 300 to 500
milliseconds. This rate is unacceptably slow, as a primary use case would
include hundreds if not thousands of permits.

It is hoped that the 4 byte index hash doesn't provide enough information to
significantly reduce security of the shared keys or curve25519 keys they are
derived from. Any feedback on this would be greatfully welcomed, as I am a noob.

 ~~<3 Raina
